<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wissenschaftlicher Taschenrechner</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --ui-font-size: 15px;
            --calc-bg: #f8fafc;
            --calc-border: #d3dae4;
            --display-start: #0b3e5c;
            --display-end: #165a7a;
            --panel-bg: #e7edf4;
            --panel-border: #c3cedb;
            --panel-active-bg: #cdd6e2;
            --keypad-bg: #cdd6e2;
            --key-bg: #f4f7fb;
            --key-border: #b8c3d3;
            --key-hover: #e7eef7;
            --key-text: #111827;
            --panel-text: #1f2937;
            --panel-label: #374151;
            --input-bg: #ffffff;
            --input-border: #9fb0c4;
            --input-border-focus: #2f6f91;
            --input-text: #0b0f16;
            --operator-bg: #14537a;
            --operator-hover: #0f3f5d;
            --danger-bg: #e35656;
            --danger-hover: #cc4242;
            --success-bg: #2f9d6a;
            --success-hover: #278459;
            --transition-fast: 150ms;
            --transition-panel: 280ms;
        }

        html,
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: transparent;
        }

        .calculator {
            background: var(--calc-bg);
            border-radius: 20px;
            max-width: 400px;
            width: 100%;
            overflow: hidden;
            touch-action: pan-y;
            border: 1px solid var(--calc-border);
            font-size: var(--ui-font-size);
            scrollbar-width: auto;
            scrollbar-color: var(--key-border) var(--panel-bg);
        }

        .calculator::-webkit-scrollbar {
            width: 12px;
        }

        .calculator::-webkit-scrollbar-thumb {
            background: var(--key-border);
            border-radius: 10px;
        }

        .calculator::-webkit-scrollbar-track {
            background: var(--panel-bg);
        }

        .display {
            background: linear-gradient(135deg, var(--display-start) 0%, var(--display-end) 100%);
            padding: 16px 18px;
            color: white;
            position: relative;
            touch-action: none;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
        }

        .display * {
            user-select: none;
            -webkit-user-select: none;
        }

        .calculator.dragging .display,
        .calculator.dragging .display * {
            cursor: grabbing;
        }

        .result-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .result-display {
            flex: 1;
            font-size: 24px;
            font-weight: 300;
            min-height: 36px;
            text-align: right;
            word-wrap: break-word;
            font-family: 'Segoe UI', 'Segoe UI Symbol', 'Courier New', Courier, monospace;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            line-height: 1.1;
        }

        .result-display.updated {
            animation: resultPulse 360ms ease;
        }

        @keyframes resultPulse {

            0%,
            100% {
                transform: scale(1);
                text-shadow: 0 0 0 rgba(255, 255, 255, 0);
            }

            45% {
                transform: scale(1.04);
                text-shadow: 0 0 12px rgba(255, 255, 255, 0.7);
            }
        }

        .copy-result {
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.9);
            width: 32px;
            height: 32px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            cursor: pointer;
            padding: 0;
            position: relative;
            transition: color var(--transition-fast);
        }

        .copy-result svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
        }

        .copy-result:hover {
            color: #ffffff;
        }

        .copy-check {
            position: absolute;
            right: -3px;
            bottom: -3px;
            font-size: 11px;
            line-height: 1;
            color: #0f6b3a;
            background: #ffffff;
            border: 1px solid rgba(15, 107, 58, 0.35);
            border-radius: 999px;
            padding: 2px 3px;
            opacity: 0;
            transform: scale(0.8);
            transition: opacity 0.2s ease, transform 0.2s ease;
            pointer-events: none;
        }

        .copy-result.copied .copy-check {
            opacity: 1;
            transform: scale(1);
        }

        .special-functions {
            background: var(--panel-bg);
            padding: 6px;
            border-bottom: 1px solid var(--panel-border);
            position: relative;
        }

        .function-buttons {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .function-buttons button {
            flex: 1;
            min-width: 70px;
            padding: 6px;
            border: 1px solid var(--key-border);
            border-radius: 8px;
            cursor: pointer;
            transition: all var(--transition-fast);
            font-weight: 600;
            background: var(--key-bg);
            color: var(--key-text);
        }

        .function-buttons button:hover {
            background: var(--key-hover);
            transform: translateY(-1px);
        }

        .function-buttons button.active {
            background: var(--panel-active-bg);
        }

        .panels-container {
            position: relative;
            overflow: hidden;
        }

        .expandable {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            opacity: 0;
            transform: translateY(-10px);
            pointer-events: none;
            transition: opacity var(--transition-panel) ease,
                transform var(--transition-panel) ease;
        }

        .expandable.open {
            position: relative;
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .panel {
            background: white;
            padding: 6px;
            border-radius: 6px;
            margin-top: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .panel h4 {
            margin-bottom: 3px;
            color: var(--panel-text);
            font-size: inherit;
            font-weight: 500;
        }

        .input-group {
            margin-bottom: 2px;
        }

        .input-group label {
            display: block;
            margin-bottom: 2px;
            color: var(--panel-label);
            font-weight: 500;
            font-size: 14px;
        }

        .input-group input,
        .input-row input {
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: inherit;
            font-family: inherit;
            font-weight: 600;
            background: var(--input-bg);
            color: var(--input-text);
            caret-color: var(--input-text);
            transition: border-color var(--transition-fast), background-color var(--transition-fast);
        }

        .input-group input {
            width: 100%;
            padding: 5px 7px;
        }

        .input-row input {
            width: 40px;
            padding: 3px 2px;
            text-align: center;
        }

        input[type=number] {
            appearance: textfield;
        }

        input[type=number]::-webkit-outer-spin-button,
        input[type=number]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        input:focus {
            outline: 1px solid var(--input-border-focus);
            outline-offset: 0;
            border-color: var(--input-border-focus);
            background: #eef6fb;
        }

        .input-row {
            display: flex;
            gap: 2px;
            margin-bottom: 2px;
            align-items: center;
            flex-wrap: wrap;
        }

        .panel label {
            color: var(--panel-label);
            font-weight: 500;
        }

        .binom-row {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 1px;
        }

        .binom-field {
            display: flex;
            flex-direction: column;
            gap: 0;
            min-width: 0;
        }

        .binom-input {
            display: flex;
            align-items: stretch;
            gap: 1px;
        }

        .binom-input input {
            flex: 1;
            min-width: 0;
            padding: 3px 2px;
            font-size: 14px;
        }

        .binom-stepper {
            display: flex;
            flex-direction: column;
            gap: 0;
        }

        .binom-step {
            width: 20px;
            height: 18px;
            padding: 0;
            border-radius: 4px;
            font-size: inherit;
            border: 1px solid var(--key-border);
            background: var(--key-bg);
            color: var(--key-text);
            cursor: pointer;
            transition: background-color var(--transition-fast);
        }

        .binom-step:hover {
            background: var(--key-hover);
        }

        .lgs-operator,
        .lgs-var-label,
        .lgs-equals {
            padding: 0 2px;
            font-weight: 500;
            color: var(--panel-label);
            font-size: 13px;
        }

        .lgs-matrix {
            margin-bottom: 2px;
        }

        .lgs-controls {
            display: flex;
            gap: 3px;
            margin-bottom: 4px;
        }

        .lgs-controls button {
            flex: 1;
            padding: 4px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #48bb78;
            color: white;
            transition: background-color var(--transition-fast);
        }

        .lgs-controls button:hover {
            background: #38a169;
        }

        .lgs-controls button.remove {
            background: #f56565;
        }

        .lgs-controls button.remove:hover {
            background: #e53e3e;
        }

        .buttons {
            padding: 8px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2px;
            background: var(--keypad-bg);
        }

        button {
            padding: 8px;
            font-size: inherit;
            border: 1px solid var(--key-border);
            border-radius: 8px;
            cursor: pointer;
            transition: all var(--transition-fast);
            font-weight: 500;
            background: var(--key-bg);
            color: var(--key-text);
        }

        button:hover {
            transform: translateY(-1px);
            background: var(--key-hover);
        }

        button:active {
            transform: translateY(0);
        }

        .operator {
            background: var(--operator-bg);
            color: white;
        }

        .operator:hover {
            background: var(--operator-hover);
        }

        .equals {
            background: var(--success-bg);
            color: white;
        }

        .equals:hover {
            background: var(--success-hover);
        }

        .clear {
            background: var(--danger-bg);
            color: white;
        }

        .clear:hover {
            background: var(--danger-hover);
        }

        .key-popover {
            position: relative;
            display: flex;
        }

        .key-popover>button {
            width: 100%;
        }

        .key-popover-menu {
            position: absolute;
            left: 0;
            right: 0;
            bottom: calc(100% + 6px);
            background: var(--keypad-bg);
            border: 1px solid var(--key-border);
            border-radius: 10px;
            padding: 6px;
            display: none;
            grid-template-columns: minmax(0, 1fr);
            gap: 4px;
            z-index: 5;
            box-shadow: 0 8px 18px rgba(0, 0, 0, 0.18);
        }

        .key-popover.open .key-popover-menu {
            display: grid;
        }

        .key-popover-menu button {
            padding: 6px 4px;
            font-weight: 600;
        }

        @media (max-width: 600px) {
            .result-display {
                font-size: 30px;
            }

            button {
                padding: 7px;
            }

            .binom-step {
                width: 22px;
                height: 18px;
            }
        }
    </style>
</head>

<body>
    <div class="calculator">
        <div class="display">
            <div class="result-row">
                <div class="result-display" id="resultDisplay">0</div>
                <button class="copy-result" id="copyResultButton" onclick="copyResult()" aria-label="Ergebnis kopieren"
                    title="Ergebnis kopieren">
                    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                        <path
                            d="M16 1H6c-1.1 0-2 .9-2 2v12h2V3h10V1zm3 4H10c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h9c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H10V7h9v14z" />
                    </svg>
                    <span class="copy-check" aria-hidden="true">✓</span>
                </button>
            </div>
        </div>

        <div class="special-functions">
            <div class="function-buttons">
                <button onclick="togglePanel('cal')" id="calBtn">CAL</button>
                <button onclick="togglePanel('lgs')" id="lgsBtn">LGS</button>
                <button onclick="togglePanel('binom')" id="binomBtn">BIN</button>
            </div>

            <div class="panels-container">
                <!-- CAL Panel (kombiniert mit SOL) -->
                <div id="calPanel" class="expandable">
                    <div class="panel">
                        <h4></h4>
                        <div class="input-group">
                            <input type="text" id="calInput" inputmode="decimal" autocomplete="off">
                        </div>
                    </div>
                </div>

                <!-- LGS Panel -->
                <div id="lgsPanel" class="expandable">
                    <div class="panel">
                        <h4></h4>
                        <div class="lgs-controls">
                            <button onclick="addLGSVariable()">+ Var.</button>
                            <button class="remove" onclick="removeLGSVariable()">- Var.</button>
                            <button onclick="addLGSEquation()">+ Gl.</button>
                            <button class="remove" onclick="removeLGSEquation()">- Gl.</button>
                        </div>
                        <div id="lgsMatrix"></div>
                    </div>
                </div>

                <!-- Binomial Panel -->
                <div id="binomPanel" class="expandable">
                    <div class="panel">
                        <h4>P(a ≤ X ≤ b):</h4>
                        <div class="binom-row">
                            <div class="binom-field">
                                <label class="panel-label" for="binomA">a =</label>
                                <div class="binom-input">
                                    <input type="text" id="binomA" inputmode="decimal" autocomplete="off">
                                    <div class="binom-stepper" aria-hidden="true">
                                        <button type="button" class="binom-step" data-target="binomA" data-step="1"
                                            aria-label="a erhöhen" tabindex="-1">▲</button>
                                        <button type="button" class="binom-step" data-target="binomA" data-step="-1"
                                            aria-label="a verringern" tabindex="-1">▼</button>
                                    </div>
                                </div>
                            </div>
                            <div class="binom-field">
                                <label class="panel-label" for="binomB">b =</label>
                                <div class="binom-input">
                                    <input type="text" id="binomB" inputmode="decimal" autocomplete="off">
                                    <div class="binom-stepper" aria-hidden="true">
                                        <button type="button" class="binom-step" data-target="binomB" data-step="1"
                                            aria-label="b erhöhen" tabindex="-1">▲</button>
                                        <button type="button" class="binom-step" data-target="binomB" data-step="-1"
                                            aria-label="b verringern" tabindex="-1">▼</button>
                                    </div>
                                </div>
                            </div>
                            <div class="binom-field">
                                <label class="panel-label" for="binomN">n =</label>
                                <div class="binom-input">
                                    <input type="text" id="binomN" inputmode="decimal" autocomplete="off">
                                    <div class="binom-stepper" aria-hidden="true">
                                        <button type="button" class="binom-step" data-target="binomN" data-step="1"
                                            aria-label="n erhöhen" tabindex="-1">▲</button>
                                        <button type="button" class="binom-step" data-target="binomN" data-step="-1"
                                            aria-label="n verringern" tabindex="-1">▼</button>
                                    </div>
                                </div>
                            </div>
                            <div class="binom-field">
                                <label class="panel-label" for="binomP">p =</label>
                                <div class="binom-input">
                                    <input type="text" id="binomP" inputmode="decimal" autocomplete="off">
                                    <div class="binom-stepper" aria-hidden="true">
                                        <button type="button" class="binom-step" data-target="binomP" data-step="0.01"
                                            aria-label="p erhöhen" tabindex="-1">▲</button>
                                        <button type="button" class="binom-step" data-target="binomP" data-step="-0.01"
                                            aria-label="p verringern" tabindex="-1">▼</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="buttons">
            <!-- Reihe 1 -->
            <button class="top-key" onclick="appendOperator('√')">x√y</button>
            <div class="key-popover" id="constKey">
                <button class="top-key" type="button" onclick="toggleKeyPopover('constPopover', this)"
                    aria-expanded="false" aria-controls="constPopover">const</button>
                <div class="key-popover-menu" id="constPopover" role="menu">
                    <button type="button" onclick="appendNumber('π'); closeKeyPopovers()">π</button>
                    <button type="button" onclick="appendNumber('e'); closeKeyPopovers()">e</button>
                </div>
            </div>
            <div class="key-popover" id="triKey">
                <button class="top-key" type="button" onclick="toggleKeyPopover('triPopover', this)"
                    aria-expanded="false" aria-controls="triPopover">tri</button>
                <div class="key-popover-menu" id="triPopover" role="menu">
                    <button type="button" onclick="appendFunction('sin('); closeKeyPopovers()">sin</button>
                    <button type="button" onclick="appendFunction('cos('); closeKeyPopovers()">cos</button>
                    <button type="button" onclick="appendFunction('tan('); closeKeyPopovers()">tan</button>
                </div>
            </div>
            <button class="clear" onclick="clearAll()">C</button>

            <!-- Reihe 2 -->
            <button class="top-key" onclick="factorial()">n!</button>
            <button class="top-key" onclick="appendOperator('^')">^</button>
            <button class="top-key" type="button" onclick="appendAutoParen()">()</button>
            <button class="clear" onclick="backspace()">⌫</button>

            <!-- Reihe 3 -->
            <button class="top-key" onclick="appendOperator('=')">=</button>
            <button class="top-key" onclick="appendNumber('x')">x</button>
            <div class="key-popover" id="logKey">
                <button class="top-key" type="button" onclick="toggleKeyPopover('logPopover', this)"
                    aria-expanded="false" aria-controls="logPopover">log</button>
                <div class="key-popover-menu" id="logPopover" role="menu">
                    <button type="button" onclick="appendLogTemplate(); closeKeyPopovers()">log_()()</button>
                    <button type="button" onclick="appendFunction('ln('); closeKeyPopovers()">ln</button>
                </div>
            </div>
            <button class="operator" onclick="appendOperator('/')">÷</button>

            <!-- Reihe 4-7 -->
            <button onclick="appendNumber('7')">7</button>
            <button onclick="appendNumber('8')">8</button>
            <button onclick="appendNumber('9')">9</button>
            <button class="operator" onclick="appendOperator('*')">×</button>

            <button onclick="appendNumber('4')">4</button>
            <button onclick="appendNumber('5')">5</button>
            <button onclick="appendNumber('6')">6</button>
            <button class="operator" onclick="appendOperator('-')">−</button>

            <button onclick="appendNumber('1')">1</button>
            <button onclick="appendNumber('2')">2</button>
            <button onclick="appendNumber('3')">3</button>
            <button class="operator" onclick="appendOperator('+')">+</button>

            <button onclick="toggleSign()">+/-</button>
            <button onclick="appendNumber('0')">0</button>
            <button onclick="appendNumber('.')">.</button>
            <button class="equals" onclick="handleExecute()">EXE</button>
        </div>
    </div>

    <script>
        let currentInput = '0';
        let result = 0;
        let shouldResetInput = false;
        let lgsVariables = 2;
        let lgsEquations = 2;
        let activePanel = null;
        let activeInputField = null;
        let panelInputMode = false;
        let shouldAnimateResult = false;
        let copyFeedbackTimer = null;

        const isTouchDevice = (() => {
            if (window.matchMedia && window.matchMedia('(pointer: coarse)').matches) return true;
            return navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
        })();

        const isFinePointer = window.matchMedia ? window.matchMedia('(pointer: fine)').matches : false;
        const isProbablyMobile = (() => {
            if (navigator.userAgentData && typeof navigator.userAgentData.mobile === 'boolean') {
                return navigator.userAgentData.mobile;
            }
            return /Android|iPhone|iPad|iPod|IEMobile|Opera Mini/i.test(navigator.userAgent);
        })();

        const shouldLockTouchInputs = isTouchDevice && isProbablyMobile && !isFinePointer;

        function updateDisplay() {
            const resultDisplay = document.getElementById('resultDisplay');
            if (resultDisplay) {
                resultDisplay.textContent = result;
                if (shouldAnimateResult) {
                    resultDisplay.classList.remove('updated');
                    void resultDisplay.offsetWidth;
                    resultDisplay.classList.add('updated');
                    shouldAnimateResult = false;
                }
            }
        }

        function copyResult() {
            const value = String(result ?? '').trim();
            if (!value) return;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(value)
                    .then(() => showCopyFeedback())
                    .catch(() => fallbackCopy(value));
                return;
            }

            fallbackCopy(value);
        }

        function fallbackCopy(value) {
            const temp = document.createElement('textarea');
            temp.value = value;
            temp.setAttribute('readonly', '');
            temp.style.position = 'absolute';
            temp.style.left = '-9999px';
            document.body.appendChild(temp);
            temp.select();
            document.execCommand('copy');
            document.body.removeChild(temp);
            showCopyFeedback();
        }

        function showCopyFeedback() {
            const copyButton = document.getElementById('copyResultButton');
            if (!copyButton) return;
            copyButton.classList.remove('copied');
            void copyButton.offsetWidth;
            copyButton.classList.add('copied');
            if (copyFeedbackTimer) {
                clearTimeout(copyFeedbackTimer);
            }
            copyFeedbackTimer = setTimeout(() => {
                copyButton.classList.remove('copied');
            }, 1200);
        }

        function applyTouchInputLock() {
            const inputs = document.querySelectorAll('#calPanel input, #binomPanel input, #lgsPanel input');
            inputs.forEach((input) => {
                if (!input.dataset.defaultInputMode) {
                    input.dataset.defaultInputMode = input.getAttribute('inputmode') || input.inputMode || '';
                }

                if (shouldLockTouchInputs) {
                    input.readOnly = false;
                    input.inputMode = 'none';
                    input.autocapitalize = 'off';
                    input.autocomplete = 'off';
                    input.spellcheck = false;
                } else {
                    input.readOnly = false;
                    input.inputMode = input.dataset.defaultInputMode || '';
                }
            });
        }

        function appendNumber(num) {
            if (appendToActiveInput(String(num))) {
                return;
            }

            if (shouldResetInput || currentInput === '0') {
                currentInput = String(num);
                shouldResetInput = false;
            } else {
                currentInput += num;
            }
            updateDisplay();
        }

        function appendOperator(op) {
            if (appendToActiveInput(op)) {
                return;
            }

            shouldResetInput = false;
            if (currentInput.slice(-1).match(/[\+\-\*\/\=]/)) {
                currentInput = currentInput.slice(0, -1) + op;
            } else {
                currentInput += op;
            }
            updateDisplay();
        }

        function appendFunction(func) {
            if (appendToActiveInput(func)) {
                return;
            }

            if (shouldResetInput || currentInput === '0') {
                currentInput = func;
                shouldResetInput = false;
            } else {
                currentInput += func;
            }
            updateDisplay();
        }

        function appendLogTemplate() {
            if (activeInputField && panelInputMode) {
                const currentValue = activeInputField.value || '';
                const start = activeInputField.selectionStart ?? currentValue.length;
                const end = activeInputField.selectionEnd ?? start;
                const template = 'log_()()';
                activeInputField.value =
                    currentValue.slice(0, start) + template + currentValue.slice(end);
                setInputCursor(activeInputField, start + 5);
                return;
            }

            appendFunction('log_()()');
        }

        function appendAutoParen() {
            if (activeInputField && panelInputMode) {
                const currentValue = activeInputField.value || '';
                const cursor = activeInputField.selectionStart ?? currentValue.length;
                const before = currentValue.slice(0, cursor);
                const paren = shouldInsertClosingParen(before) ? ')' : '(';
                insertAtCursor(activeInputField, paren);
                return;
            }

            const paren = shouldInsertClosingParen(currentInput) ? ')' : '(';
            if (shouldResetInput || currentInput === '0') {
                currentInput = paren;
                shouldResetInput = false;
            } else {
                currentInput += paren;
            }
            updateDisplay();
        }

        function shouldInsertClosingParen(value) {
            const openCount = (value.match(/\(/g) || []).length;
            const closeCount = (value.match(/\)/g) || []).length;
            if (openCount <= closeCount) {
                return false;
            }
            const trimmed = value.replace(/\s+/g, '');
            if (!trimmed) {
                return false;
            }
            const last = trimmed[trimmed.length - 1];
            return !/[+\-*/^=,(]/.test(last);
        }

        function closeKeyPopovers() {
            const popovers = document.querySelectorAll('.key-popover');
            popovers.forEach((popover) => {
                popover.classList.remove('open');
                const trigger = popover.querySelector('button[aria-expanded]');
                if (trigger) {
                    trigger.setAttribute('aria-expanded', 'false');
                }
            });
        }

        function toggleKeyPopover(popoverId, trigger) {
            const popover = document.getElementById(popoverId);
            if (!popover) return;
            const container = popover.closest('.key-popover');
            if (!container) return;

            const isOpen = container.classList.contains('open');
            closeKeyPopovers();
            if (!isOpen) {
                container.classList.add('open');
                if (trigger) {
                    trigger.setAttribute('aria-expanded', 'true');
                }
            }
        }

        document.addEventListener('click', (event) => {
            if (!event.target.closest('.key-popover')) {
                closeKeyPopovers();
            }
        });

        function clearAll() {
            if (activePanel === 'cal') {
                const calInput = document.getElementById('calInput');
                if (calInput) {
                    calInput.value = '';
                    setInputCursor(calInput, 0);
                }
            }
            currentInput = '0';
            result = 0;
            shouldResetInput = false;
            updateDisplay();
        }

        function backspace() {
            if (activeInputField) {
                const value = activeInputField.value || '';
                const start = activeInputField.selectionStart ?? value.length;
                const end = activeInputField.selectionEnd ?? start;
                if (start !== end) {
                    activeInputField.value = value.slice(0, start) + value.slice(end);
                    setInputCursor(activeInputField, start);
                } else if (start > 0) {
                    activeInputField.value = value.slice(0, start - 1) + value.slice(end);
                    setInputCursor(activeInputField, start - 1);
                }
                return;
            }

            if (currentInput.length > 1) {
                currentInput = currentInput.slice(0, -1);
            } else {
                currentInput = '0';
            }
            updateDisplay();
        }

        function normalizeExpression(input) {
            const normalized = normalizeNumberString(input);
            let expression = addImplicitMultiplication(
                normalizeUnaryMinusExponent(
                    convertRootInfix(convertLogBaseSyntax(normalized))
                )
            );
            return normalizeConstants(expression)
                .replace(/×/g, '*')
                .replace(/÷/g, '/')
                .replace(/−/g, '-')
                .replace(/\^/g, '**')
                .replace(/sqrt\(/g, 'Math.sqrt(')
                .replace(/exp\(/g, 'Math.exp(')
                .replace(/ln\(/g, 'Math.log(')
                .replace(/sin\(/g, 'Math.sin(')
                .replace(/cos\(/g, 'Math.cos(')
                .replace(/tan\(/g, 'Math.tan(');
        }

        function calculate() {
            try {
                const expression = normalizeExpression(currentInput);
                result = eval(expression);
                result = Math.round(result * 1000000000) / 1000000000;
                shouldResetInput = true;
                updateDisplay();
            } catch (error) {
                result = 'Fehler';
                updateDisplay();
            }
        }

        function handleExecute() {
            shouldAnimateResult = true;
            if (!executeActivePanel()) {
                calculate();
            }
        }

        function executeActivePanel() {
            if (activePanel === 'cal') {
                const calInput = document.getElementById('calInput');
                if (calInput) {
                    const inputValue = calInput.value || '0';
                    const equalsCount = (inputValue.match(/=/g) || []).length;

                    // Wenn genau ein "=" vorhanden ist -> Gleichung lösen
                    if (equalsCount === 1) {
                        solveEquation(inputValue);
                    } else {
                        // Sonst berechnen
                        currentInput = inputValue;
                        calculate();
                    }
                }
                return true;
            }
            if (activePanel === 'lgs') {
                solveLGS();
                return true;
            }
            if (activePanel === 'binom') {
                calculateBinomial();
                return true;
            }
            return false;
        }

        function focusPanelInput(panelName) {
            let input = null;
            if (panelName === 'cal') {
                input = document.getElementById('calInput');
                if (input && (!input.value || input.value === '0')) {
                    input.value = '';
                }
            } else if (panelName === 'binom') {
                input = document.querySelector('#binomPanel input');
            } else if (panelName === 'lgs') {
                input = document.querySelector('#lgsPanel input');
            }

            if (!input) {
                activeInputField = null;
                panelInputMode = false;
                return;
            }

            activeInputField = input;
            panelInputMode = true;
            setInputCursor(input, (input.value || '').length);
        }

        function addImplicitMultiplication(value) {
            return value
                .replace(/(\d)([a-zA-Zπ(])/g, '$1*$2')
                .replace(/(\))([\d(])/g, '$1*$2')
                .replace(/(\))([a-zA-Zπ])/g, '$1*$2');
        }

        function normalizeUnaryMinusExponent(value) {
            return value
                .replace(/(^|[+\-*/(=])\s*-\s*([a-zA-Z0-9.]+)\s*\^/g, '$1(-1)*$2^')
                .replace(/(^|[+\-*/(=])\s*-\s*(\([^()]*\))\s*\^/g, '$1(-1)*$2^');
        }

        function normalizeConstants(value) {
            return value
                .replace(/(^|[^a-zA-Z0-9_.])e([^a-zA-Z0-9_]|$)/g, '$1Math.E$2')
                .replace(/(^|[^a-zA-Z0-9_.])pi([^a-zA-Z0-9_]|$)/gi, '$1Math.PI$2')
                .replace(/π/g, 'Math.PI');
        }

        function convertRootInfix(value) {
            let expr = value;
            let index = expr.indexOf('√');

            while (index !== -1) {
                const left = findLeftOperand(expr, index - 1);
                const right = findRightOperand(expr, index + 1);

                if (!left || !right) {
                    break;
                }

                const leftValue = expr.slice(left.start, left.end + 1);
                const rightValue = expr.slice(right.start, right.end + 1);

                expr = `${expr.slice(0, left.start)}root(${leftValue},${rightValue})${expr.slice(right.end + 1)}`;
                index = expr.indexOf('√');
            }

            return expr;
        }

        function convertLogBaseSyntax(value) {
            let expr = value;
            let index = expr.indexOf('log_(');

            while (index !== -1) {
                const baseStart = index + 4;
                const base = extractParenthesized(expr, baseStart);
                if (!base) {
                    break;
                }

                const afterBase = base.end + 1;
                const valueStart = findNextNonSpace(expr, afterBase);
                if (valueStart === null || expr[valueStart] !== '(') {
                    break;
                }

                const valuePart = extractParenthesized(expr, valueStart);
                if (!valuePart) {
                    break;
                }

                const baseValue = expr.slice(base.start + 1, base.end);
                const valueValue = expr.slice(valuePart.start + 1, valuePart.end);
                expr = `${expr.slice(0, index)}logBase(${baseValue},${valueValue})${expr.slice(valuePart.end + 1)}`;
                index = expr.indexOf('log_(');
            }

            return expr;
        }

        function extractParenthesized(expr, startIndex) {
            if (expr[startIndex] !== '(') {
                return null;
            }

            let depth = 1;
            let i = startIndex + 1;
            while (i < expr.length) {
                if (expr[i] === '(') depth++;
                if (expr[i] === ')') depth--;
                if (depth === 0) break;
                i++;
            }
            if (i >= expr.length) {
                return null;
            }
            return { start: startIndex, end: i };
        }

        function findNextNonSpace(expr, startIndex) {
            let i = startIndex;
            while (i < expr.length && expr[i] === ' ') {
                i++;
            }
            return i < expr.length ? i : null;
        }

        function logBase(base, value) {
            return Math.log(value) / Math.log(base);
        }

        function findLeftOperand(expr, endIndex) {
            let end = endIndex;
            while (end >= 0 && expr[end] === ' ') {
                end--;
            }
            if (end < 0) return null;

            if (expr[end] === ')') {
                let depth = 1;
                let i = end - 1;
                while (i >= 0) {
                    if (expr[i] === ')') depth++;
                    if (expr[i] === '(') depth--;
                    if (depth === 0) break;
                    i--;
                }
                if (i < 0) return null;
                return { start: i, end };
            }

            let i = end;
            while (i >= 0 && /[a-zA-Z0-9.]/.test(expr[i])) {
                i--;
            }
            let start = i + 1;
            if (start > 0 && expr[start - 1] === '-' && (start - 1 === 0 || /[+\-*/(=]/.test(expr[start - 2]))) {
                start--;
            }
            return start <= end ? { start, end } : null;
        }

        function findRightOperand(expr, startIndex) {
            let start = startIndex;
            while (start < expr.length && expr[start] === ' ') {
                start++;
            }
            if (start >= expr.length) return null;

            if (expr[start] === '(') {
                let depth = 1;
                let i = start + 1;
                while (i < expr.length) {
                    if (expr[i] === '(') depth++;
                    if (expr[i] === ')') depth--;
                    if (depth === 0) break;
                    i++;
                }
                if (i >= expr.length) return null;
                return { start, end: i };
            }

            let i = start;
            if (expr[i] === '-' && i + 1 < expr.length && /[a-zA-Z0-9(]/.test(expr[i + 1])) {
                i++;
            }
            while (i < expr.length && /[a-zA-Z0-9.]/.test(expr[i])) {
                i++;
            }
            const end = i - 1;
            return end >= start ? { start, end } : null;
        }

        function root(x, y) {
            return Math.pow(y, 1 / x);
        }

        function toggleSign() {
            if (activeInputField) {
                const value = activeInputField.value || '';
                if (value.startsWith('-')) {
                    activeInputField.value = value.slice(1);
                } else if (value.length > 0) {
                    activeInputField.value = '-' + value;
                }
                return;
            }

            const numericPattern = /^-?\d+(\.\d+)?$/;
            if (numericPattern.test(currentInput)) {
                currentInput = currentInput.startsWith('-') ? currentInput.slice(1) : '-' + currentInput;
                updateDisplay();
            }
        }

        function appendToActiveInput(value) {
            if (!activeInputField || !panelInputMode) {
                return false;
            }

            const currentValue = activeInputField.value || '';
            if (activeInputField.type === 'number' || activeInputField.type === 'text') {
                const isSeparator = value === '.' || value === ',';
                const isExpressionInput = activeInputField.id === 'calInput';

                if (isSeparator && isExpressionInput) {
                    const cursor = activeInputField.selectionStart ?? currentValue.length;
                    const left = currentValue.slice(0, cursor);
                    let i = left.length - 1;
                    while (i >= 0 && /[0-9.,]/.test(left[i])) {
                        i--;
                    }
                    const segment = left.slice(i + 1);
                    const hasSeparator = segment.includes('.') || segment.includes(',');
                    if (hasSeparator) {
                        return true;
                    }
                    if (segment === '') {
                        insertAtCursor(activeInputField, `0${value}`);
                        return true;
                    }
                } else if (isSeparator) {
                    const hasSeparator = currentValue.includes('.') || currentValue.includes(',');
                    if (hasSeparator) {
                        return true;
                    }
                    if (currentValue === '' || currentValue === '-') {
                        activeInputField.value = `${currentValue}0${value}`;
                        return true;
                    }
                }
            }

            insertAtCursor(activeInputField, value);
            return true;
        }

        function insertAtCursor(input, value) {
            const currentValue = input.value || '';
            const start = input.selectionStart ?? currentValue.length;
            const end = input.selectionEnd ?? start;
            input.value = currentValue.slice(0, start) + value + currentValue.slice(end);
            setInputCursor(input, start + value.length);
        }

        function setInputCursor(input, position) {
            input.focus({ preventScroll: true });
            if (input.setSelectionRange) {
                input.setSelectionRange(position, position);
            }
        }

        function normalizeNumberString(value) {
            return value.replace(/,/g, '.');
        }

        function factorial() {
            try {
                let n = parseInt(result || currentInput);
                if (n < 0) {
                    result = 'Fehler';
                } else if (n === 0 || n === 1) {
                    result = 1;
                } else {
                    let fact = 1;
                    for (let i = 2; i <= n; i++) {
                        fact *= i;
                    }
                    result = fact;
                }
                currentInput = String(result);
                shouldResetInput = true;
                updateDisplay();
            } catch (error) {
                result = 'Fehler';
                updateDisplay();
            }
        }

        function togglePanel(panelName) {
            const panels = ['cal', 'lgs', 'binom'];
            const buttons = ['calBtn', 'lgsBtn', 'binomBtn'];

            if (activePanel === panelName) {
                const panel = document.getElementById(panelName + 'Panel');
                const btn = document.getElementById(panelName + 'Btn');
                panel.classList.remove('open');
                btn.classList.remove('active');
                activePanel = null;
                activeInputField = null;
                panelInputMode = false;
                postCalculatorSize();
                setTimeout(postCalculatorSize, 300);
                return;
            }

            panels.forEach((p, idx) => {
                const panel = document.getElementById(p + 'Panel');
                const btn = document.getElementById(buttons[idx]);

                if (p === panelName) {
                    panel.classList.add('open');
                    btn.classList.add('active');
                } else {
                    panel.classList.remove('open');
                    btn.classList.remove('active');
                }
            });

            activePanel = panelName;
            focusPanelInput(panelName);

            postCalculatorSize();
            setTimeout(postCalculatorSize, 300);
        }

        // LGS Functions
        function initLGS() {
            lgsVariables = 2;
            lgsEquations = 2;
            renderLGS();
        }

        function renderLGS() {
            const container = document.getElementById('lgsMatrix');
            const existingValues = {};

            container.querySelectorAll('input').forEach((input) => {
                existingValues[input.id] = input.value;
            });
            container.innerHTML = '';

            const varNames = ['x', 'y', 'z', 'u', 'v', 'w'];

            for (let i = 0; i < lgsEquations; i++) {
                const row = document.createElement('div');
                row.className = 'input-row';

                for (let j = 0; j < lgsVariables; j++) {
                    if (j > 0) {
                        const plusMinus = document.createElement('span');
                        plusMinus.textContent = '+';
                        plusMinus.className = 'lgs-operator';
                        row.appendChild(plusMinus);
                    }

                    const input = document.createElement('input');
                    input.type = 'text';
                    input.inputMode = 'decimal';
                    input.readOnly = false;
                    input.id = `a${i}${j}`;
                    input.placeholder = '';
                    input.value = existingValues[input.id] ?? '';
                    row.appendChild(input);

                    const varLabel = document.createElement('span');
                    varLabel.textContent = varNames[j] || `x${j + 1}`;
                    varLabel.className = 'lgs-var-label';
                    row.appendChild(varLabel);
                }

                const equals = document.createElement('span');
                equals.textContent = '=';
                equals.className = 'lgs-equals';
                row.appendChild(equals);

                const resultInput = document.createElement('input');
                resultInput.type = 'text';
                resultInput.inputMode = 'decimal';
                resultInput.readOnly = false;
                resultInput.id = `b${i}`;
                resultInput.placeholder = '';
                resultInput.value = existingValues[resultInput.id] ?? '';
                row.appendChild(resultInput);

                container.appendChild(row);
            }

            applyTouchInputLock();
        }

        function addLGSVariable() {
            if (lgsVariables < 5) {
                lgsVariables++;
                renderLGS();
            }
        }

        function removeLGSVariable() {
            if (lgsVariables > 1) {
                lgsVariables--;
                renderLGS();
            }
        }

        function addLGSEquation() {
            if (lgsEquations < 5) {
                lgsEquations++;
                renderLGS();
            }
        }

        function removeLGSEquation() {
            if (lgsEquations > 1) {
                lgsEquations--;
                renderLGS();
            }
        }

        function solveLGS() {
            try {
                const A = [];
                const b = [];

                for (let i = 0; i < lgsEquations; i++) {
                    A[i] = [];
                    for (let j = 0; j < lgsVariables; j++) {
                        const cellValue = document.getElementById(`a${i}${j}`).value;
                        A[i][j] = parseFloat(normalizeNumberString(cellValue)) || 0;
                    }
                    const resultValue = document.getElementById(`b${i}`).value;
                    b[i] = parseFloat(normalizeNumberString(resultValue)) || 0;
                }

                const solution = solveLinearSystem(A, b);

                if (solution.status === 'inconsistent') {
                    currentInput = 'LGS: Keine Lösung';
                    result = 'Keine Lösung';
                } else if (solution.status === 'infinite') {
                    currentInput = 'LGS: Unendlich viele Lösungen';
                    result = solution.parametric
                        .map((expr) => expr.replace(/^x(\d+)/, (_, num) => `x${toSubscript(num)}`))
                        .join(', ');
                } else {
                    currentInput = 'LGS gelöst';
                    result = solution.values
                        .map((x, i) => `x${toSubscript(i + 1)}=${formatNumber(x)}`)
                        .join(', ');
                }

                shouldResetInput = true;
                updateDisplay();
            } catch (error) {
                currentInput = 'LGS Fehler';
                result = 'Fehler';
                updateDisplay();
            }
        }

        function solveLinearSystem(A, b) {
            const rows = A.length;
            const cols = A[0]?.length || 0;
            const augmented = A.map((row, i) => [...row, b[i]]);
            const pivotCols = [];
            let r = 0;
            const eps = 1e-10;

            for (let c = 0; c < cols && r < rows; c++) {
                let pivotRow = r;
                for (let i = r + 1; i < rows; i++) {
                    if (Math.abs(augmented[i][c]) > Math.abs(augmented[pivotRow][c])) {
                        pivotRow = i;
                    }
                }

                if (Math.abs(augmented[pivotRow][c]) < eps) {
                    continue;
                }

                if (pivotRow !== r) {
                    [augmented[r], augmented[pivotRow]] = [augmented[pivotRow], augmented[r]];
                }

                const pivotVal = augmented[r][c];
                for (let j = c; j <= cols; j++) {
                    augmented[r][j] /= pivotVal;
                }

                for (let i = 0; i < rows; i++) {
                    if (i === r) continue;
                    const factor = augmented[i][c];
                    if (Math.abs(factor) < eps) continue;
                    for (let j = c; j <= cols; j++) {
                        augmented[i][j] -= factor * augmented[r][j];
                    }
                }

                pivotCols.push(c);
                r++;
            }

            for (let i = 0; i < rows; i++) {
                let allZero = true;
                for (let j = 0; j < cols; j++) {
                    if (Math.abs(augmented[i][j]) >= eps) {
                        allZero = false;
                        break;
                    }
                }
                if (allZero && Math.abs(augmented[i][cols]) >= eps) {
                    return { status: 'inconsistent' };
                }
            }

            if (pivotCols.length === cols) {
                const values = new Array(cols).fill(0);
                for (let i = 0; i < pivotCols.length; i++) {
                    const col = pivotCols[i];
                    values[col] = augmented[i][cols];
                }
                return { status: 'unique', values };
            }

            const freeCols = [];
            for (let j = 0; j < cols; j++) {
                if (!pivotCols.includes(j)) {
                    freeCols.push(j);
                }
            }

            const paramNames = ['t', 's', 'r', 'u', 'v', 'w'];
            const paramMap = new Map();
            freeCols.forEach((col, idx) => {
                paramMap.set(col, paramNames[idx] || `p${idx + 1}`);
            });

            const expressions = new Array(cols).fill('0');

            freeCols.forEach((col) => {
                expressions[col] = paramMap.get(col);
            });

            for (let i = 0; i < pivotCols.length; i++) {
                const col = pivotCols[i];
                let expr = formatNumber(augmented[i][cols]);
                freeCols.forEach((freeCol) => {
                    const coeff = -augmented[i][freeCol];
                    if (Math.abs(coeff) < eps) return;
                    const sign = coeff >= 0 ? ' + ' : ' - ';
                    const absCoeff = Math.abs(coeff);
                    const coeffText = absCoeff === 1 ? '' : formatNumber(absCoeff);
                    expr += `${sign}${coeffText}${paramMap.get(freeCol)}`;
                });
                expressions[col] = expr;
            }

            const parametric = expressions.map((expr, idx) => `x${idx + 1}=${expr}`);
            return { status: 'infinite', parametric };
        }

        function formatNumber(value) {
            const rounded = Math.round(value * 1000000) / 1000000;
            const text = rounded.toFixed(6);
            return text.replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
        }

        const subscriptMap = {
            '0': '₀', '1': '₁', '2': '₂', '3': '₃', '4': '₄',
            '5': '₅', '6': '₆', '7': '₇', '8': '₈', '9': '₉'
        };

        function toSubscript(num) {
            return String(num)
                .split('')
                .map((char) => subscriptMap[char] ?? char)
                .join('');
        }

        // Binomial
        function binomialCoefficient(n, k) {
            if (k < 0 || k > n) return 0;
            if (k === 0 || k === n) return 1;

            let result = 1;
            for (let i = 1; i <= k; i++) {
                result *= (n - k + i) / i;
            }
            return Math.round(result);
        }

        function calculateBinomial() {
            const nInput = document.getElementById('binomN').value;
            const pInput = document.getElementById('binomP').value;
            const aInput = document.getElementById('binomA').value;
            const bInput = document.getElementById('binomB').value;

            const n = parseInt(normalizeNumberString(nInput));
            const pValue = normalizeNumberString(pInput);
            let p = NaN;
            if (pValue.includes('/')) {
                const parts = pValue.split('/').map((part) => parseFloat(part.trim()));
                if (parts.length === 2 && parts.every((part) => !Number.isNaN(part)) && parts[1] !== 0) {
                    p = parts[0] / parts[1];
                }
            } else {
                p = parseFloat(pValue);
            }
            const aRaw = parseFloat(normalizeNumberString(aInput));
            const bRaw = parseFloat(normalizeNumberString(bInput));
            const a = Math.ceil(aRaw);
            const b = Math.floor(bRaw);

            let probability = 0;
            for (let k = a; k <= b; k++) {
                const binomCoeff = binomialCoefficient(n, k);
                probability += binomCoeff * Math.pow(p, k) * Math.pow(1 - p, n - k);
            }

            const pDisplay = pInput !== '' ? pInput : String(p);
            currentInput = `Binom(a=${a}, b=${b}, n=${n}, p=${pDisplay})`;
            result = Math.round(probability * 1000000) / 1000000;
            shouldResetInput = true;
            updateDisplay();
        }

        function formatStepValue(value, step) {
            if (Math.abs(step) >= 1) {
                return String(Math.round(value));
            }
            const decimals = step.toString().split('.')[1]?.length || 0;
            const rounded = Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals);
            return String(rounded).replace(/\.0+$/, '').replace(/(\.\d*?)0+$/, '$1');
        }

        function adjustBinomValue(targetId, step) {
            const input = document.getElementById(targetId);
            if (!input) return;
            const raw = normalizeNumberString(input.value || '0');
            const current = parseFloat(raw);
            const next = (Number.isNaN(current) ? 0 : current) + step;
            input.value = formatStepValue(next, step);
            if (activePanel === 'binom') {
                calculateBinomial();
            }
        }

        function bindBinomControls() {
            const binomInputs = document.querySelectorAll('#binomPanel input');
            binomInputs.forEach((input) => {
                input.addEventListener('input', () => {
                    if (activePanel === 'binom') {
                        calculateBinomial();
                    }
                });
            });

            const stepButtons = document.querySelectorAll('.binom-step');
            stepButtons.forEach((button) => {
                button.addEventListener('click', () => {
                    const targetId = button.dataset.target;
                    const step = parseFloat(button.dataset.step || '0');
                    if (!targetId || Number.isNaN(step)) return;
                    adjustBinomValue(targetId, step);
                });
            });
        }

        // Equation Solver
        function solveEquation(equation) {
            equation = normalizeNumberString(equation || '').trim();

            try {
                let [leftSide, rightSide] = equation.split('=').map(s => s.trim());
                if (!rightSide) rightSide = '0';

                function f(x) {
                    let expr = `(${leftSide}) - (${rightSide})`;
                    expr = addImplicitMultiplication(
                        normalizeUnaryMinusExponent(
                            convertRootInfix(convertLogBaseSyntax(expr))
                        )
                    );
                    expr = normalizeConstants(expr)
                        .replace(/x/g, `(${x})`)
                        .replace(/\^/g, '**')
                        .replace(/e\*\*/g, 'Math.E**')
                        .replace(/sqrt/g, 'Math.sqrt')
                        .replace(/root/g, 'root')
                        .replace(/exp/g, 'Math.exp')
                        .replace(/ln/g, 'Math.log')
                        .replace(/log/g, 'Math.log10')
                        .replace(/sin/g, 'Math.sin')
                        .replace(/cos/g, 'Math.cos')
                        .replace(/tan/g, 'Math.tan');
                    return eval(expr);
                }

                function refineRoot(a, b, tolerance) {
                    let fa = f(a);
                    let fb = f(b);
                    if (isNaN(fa) || isNaN(fb)) {
                        return null;
                    }
                    if (Math.abs(fa) < tolerance) return a;
                    if (Math.abs(fb) < tolerance) return b;
                    if (fa * fb > 0) return null;

                    let left = a;
                    let right = b;
                    for (let i = 0; i < 100; i++) {
                        const mid = (left + right) / 2;
                        const fm = f(mid);
                        if (isNaN(fm)) {
                            return null;
                        }
                        if (Math.abs(fm) < tolerance) {
                            return mid;
                        }
                        if (fa * fm <= 0) {
                            right = mid;
                            fb = fm;
                        } else {
                            left = mid;
                            fa = fm;
                        }
                    }
                    return (left + right) / 2;
                }

                const tolerance = 0.000001;
                const rangeMin = -1000;
                const rangeMax = 1000;
                const steps = 20000;
                const step = (rangeMax - rangeMin) / steps;
                const roots = [];

                for (let i = 0; i < steps; i++) {
                    const x1 = rangeMin + i * step;
                    const x2 = x1 + step;
                    const f1 = f(x1);
                    const f2 = f(x2);

                    if (isNaN(f1) || isNaN(f2)) {
                        continue;
                    }

                    if (Math.abs(f1) < tolerance) {
                        roots.push(x1);
                        continue;
                    }

                    if (f1 * f2 < 0) {
                        const root = refineRoot(x1, x2, tolerance);
                        if (root !== null) {
                            roots.push(root);
                        }
                    }
                }

                const uniqueRoots = roots
                    .map(r => Math.round(r * 1000000) / 1000000)
                    .sort((a, b) => a - b)
                    .filter((r, idx, arr) => idx === 0 || Math.abs(r - arr[idx - 1]) > 0.00001);

                if (uniqueRoots.length === 0) {
                    result = 'Keine Lösung';
                    currentInput = equation;
                } else {
                    result = uniqueRoots.map((root, i) => `x${toSubscript(i + 1)}=${root}`).join(', ');
                    currentInput = `${equation} →`;
                    shouldResetInput = true;
                }

                updateDisplay();
            } catch (error) {
                result = 'Fehler beim Lösen';
                currentInput = equation;
                updateDisplay();
            }
        }

        // Keyboard Support
        document.addEventListener('keydown', function (event) {
            const isPanelInputFocused = activeInputField && document.activeElement === activeInputField;
            if (isPanelInputFocused && event.key !== 'Enter') {
                return;
            }

            if (event.key === 'Dead' && (event.code === 'Backquote' || event.code === 'BracketLeft')) {
                appendOperator('^');
                event.preventDefault();
            } else if (event.key >= '0' && event.key <= '9') {
                appendNumber(event.key);
            } else if (event.key === '.' || event.key === ',') {
                appendNumber(event.key);
            } else if (event.key === '+' || event.key === '-' || event.key === '*' || event.key === '/') {
                appendOperator(event.key);
            } else if (event.key === '^') {
                appendOperator('^');
                event.preventDefault();
            } else if (event.key === '(' || event.key === ')') {
                appendNumber(event.key);
            } else if (event.key === '=') {
                appendOperator('=');
            } else if (event.key === 'Enter') {
                event.preventDefault();
                handleExecute();
            } else if (event.key === 'Escape') {
                clearAll();
            } else if (event.key === 'Backspace') {
                backspace();
            }
        });

        // Focus Management
        document.addEventListener('focusin', function (event) {
            if (event.target.tagName === 'INPUT' && event.target.type !== 'button') {
                activeInputField = event.target;
                panelInputMode = true;
            }
        });

        document.addEventListener('click', function (event) {
            const isDisplay = event.target.closest('.display');
            const isPanelArea = event.target.closest('.special-functions');
            const isKeypad = event.target.closest('.buttons');

            if (activePanel === 'cal') {
                const calInput = document.getElementById('calInput');
                if (calInput) {
                    activeInputField = calInput;
                    panelInputMode = true;
                    return;
                }
            }

            if (isDisplay || (!isPanelArea && !isKeypad)) {
                activeInputField = null;
                panelInputMode = false;
            }
        });

        // Iframe Communication
        function postCalculatorSize() {
            const calculator = document.querySelector('.calculator');
            if (!calculator || !window.parent) return;
            const rect = calculator.getBoundingClientRect();
            window.parent.postMessage(
                {
                    type: 'calculatorSize',
                    width: Math.ceil(rect.width),
                    height: Math.ceil(rect.height)
                },
                '*'
            );
        }

        function isDragAllowed(target) {
            if (!target) return false;
            if (!target.closest('.display')) return false;
            return !target.closest('button, input, select, textarea, a');
        }

        // Drag Support for iframe
        (function setupCalculatorDrag() {
            const calculator = document.querySelector('.calculator');
            if (!calculator || !window.parent) return;

            let dragging = false;

            calculator.addEventListener('pointerdown', (event) => {
                if (!isDragAllowed(event.target)) {
                    return;
                }
                event.preventDefault();
                dragging = true;
                calculator.classList.add('dragging');
                if (calculator.setPointerCapture) {
                    calculator.setPointerCapture(event.pointerId);
                }
                window.parent.postMessage(
                    {
                        type: 'calculatorDragStart',
                        clientX: event.clientX,
                        clientY: event.clientY,
                        screenX: event.screenX,
                        screenY: event.screenY
                    },
                    '*'
                );
            });

            calculator.addEventListener('pointermove', (event) => {
                if (!dragging) return;
                window.parent.postMessage(
                    {
                        type: 'calculatorDragMove',
                        clientX: event.clientX,
                        clientY: event.clientY,
                        screenX: event.screenX,
                        screenY: event.screenY
                    },
                    '*'
                );
            });

            calculator.addEventListener('pointerup', (event) => {
                if (!dragging) return;
                dragging = false;
                calculator.classList.remove('dragging');
                if (calculator.releasePointerCapture) {
                    calculator.releasePointerCapture(event.pointerId);
                }
                window.parent.postMessage({ type: 'calculatorDragEnd' }, '*');
            });

            calculator.addEventListener('pointercancel', (event) => {
                if (!dragging) return;
                dragging = false;
                calculator.classList.remove('dragging');
                if (calculator.releasePointerCapture) {
                    calculator.releasePointerCapture(event.pointerId);
                }
                window.parent.postMessage({ type: 'calculatorDragEnd' }, '*');
            });
        })();

        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'calculatorFocus') {
                if (!activePanel) {
                    togglePanel('cal');
                    return;
                }
                focusPanelInput(activePanel);
            }
            if (event.data && event.data.type === 'calculatorRequestSize') {
                postCalculatorSize();
            }
        });

        // Initialization
        initLGS();
        updateDisplay();
        applyTouchInputLock();
        bindBinomControls();

        const calInput = document.getElementById('calInput');
        if (calInput) {
            calInput.addEventListener('input', () => {
                const value = calInput.value || '';
                if (value.toLowerCase().includes('pi')) {
                    const start = calInput.selectionStart ?? value.length;
                    const end = calInput.selectionEnd ?? start;
                    const before = value.slice(0, start);
                    const selection = value.slice(start, end);
                    const after = value.slice(end);
                    const newBefore = before.replace(/pi/gi, 'π');
                    const newSelection = selection.replace(/pi/gi, 'π');
                    const newAfter = after.replace(/pi/gi, 'π');
                    const nextValue = newBefore + newSelection + newAfter;
                    if (nextValue !== value) {
                        calInput.value = nextValue;
                        const nextStart = newBefore.length;
                        const nextEnd = newBefore.length + newSelection.length;
                        calInput.setSelectionRange(nextStart, nextEnd);
                    }
                }
            });
        }

        togglePanel('cal');
        requestAnimationFrame(() => focusPanelInput('cal'));
        window.addEventListener('load', () => {
            focusPanelInput('cal');
            postCalculatorSize();
        });
        window.addEventListener('resize', () => postCalculatorSize());
        window.addEventListener('focus', () => focusPanelInput(activePanel || 'cal'));
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                focusPanelInput(activePanel || 'cal');
            }
        });
    </script>
</body>

</html>